Changes made to channel_sim.m:

```matlab
%%
%creating a randomization of UE's that guarantees outside of sep_ang
%degrees separation between UEs. Up to a maximum of rand_trials iterations

sep_ang = 5;                                %miminum degrees separation desired
rand_trials = 100;                           %number of attempts to randomly create angular spacing
count = 0;                                  %compared against rand_trials
angle_par = 1;                              %stays 1 unless UEs are adequately spaced

UE_dist = 50 + 50*rand(par.U,1);            %distance from BS between 50 and 100

while((count < rand_trials) && angle_par)   %while less than rand_trials run and UEs don't pass spacing
    UE_ang = -60+120*rand(1,par.U);                                 %generate random angles (-60,60) for each UE
    check = toeplitz([UE_ang(1) fliplr(UE_ang(2:end))], UE_ang);    %make array into circulant matrix
    check = abs(check-(UE_ang.*ones(par.U,par.U)));                 %find difference between each user and all its neighbors
    check = min(min(check(2:end,:)));                               %find minimum angles between UEs (not including with itself)
    if(check>sep_ang)
        angle_par = 0;
    else
        count = count+1;
    end
end
%If the randomly generated angles fail to meet the sep_ang criteria, print
%out to the command window, but still carry on with program.
if count == rand_trials
    'Angle miminum between UEs NOT met'             
end
UE_ang = (pi*UE_ang/180)';              %put angles into radian
UE_x_locs = UE_dist.*cos(UE_ang);       %'polar' coordinate to rectangular
UE_y_locs = UE_dist.*sin(UE_ang);       %'polar' coordinate to rectangular
UE_z_locs = 1.5*ones(par.U,1);

% place BS antennas only on y-axis at half wavelength spacing (units in m)
BS_x_locs = zeros(par.B,1);
BS_y_locs = s.wavelength/2*(-(par.B-1)/2:1:(par.B-1)/2)';
BS_z_locs = 25*ones(par.B,1); % note that the height of the transmitter is 25m
```
This code should ensure that the randomly placed users are not within a certain angular separation of its neighbors. Here, I've stated that this angle is **sep_ang = 5** which is a separation of 5 degrees. In order to keep from running infinitely, I also set a fixed number of max random placing trials in **rand_trials = 100**. The section of the sector that is inhabited by the users is between 50 and 100m away from the BS, seen as **UE_dist**. The *while* loop contains the actual trials/random placement of the users. **UE_ang** creates a random array between -60 and 60 degrees (*since I am assuming that the BS is facing East/0 degrees*).  
Next comes my process in checking if any neighbors might be within the **sep_ang** limit of another. There is most likely a dozen ways to do this (some maybe more efficient), but the method I use here should work. 
**check** creates a circulant matrix of the generated angles between -60 and 60 degrees. 

![alt text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/circulant_matrix.PNG)

Then the **UE_ang** vector is multiplied by a *ones* matrix and subtracted from **check**. This should give a column of zeros on the left, and the differences (to be taken by their absolute value) on the other entries. The minimum value along both dimensions of the resulting **check** matrix should return the smallest angular value between *neighbors*. If this value is greater than the predetermined **sep_ang** value, then the **UE_ang** vector is valid. If not, re-generate the **UE_ang** vector and repeat the process (unless reaching the maximum **rand_trials** iterations). 
I'm currently just throwing a comment to the Matlab terminal if there is a case that >**rand_trials** occurs. 
The receivers' locations are then defined using polar coordinates, radius being that generated by **UE_dist** and angle being generated by **UE_ang**. They are also all located 1.5m off the ground. 
The BS array is kept the same as previously made.
After running 1000 and having one failure, the resulting graph of accumulated distributed receivers can be seen below:

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/ideal_placed_UEs_over_1000_trials_1_failed.png)

Channel coefficients are generated using the following code:
```Matlab
%% Generate channel coefficients
c = l.get_channels; % Generate channels
csi_mat = zeros(par.B,par.U);
for i = 1:par.U
     coll = permute(c(i,1).coeff,[2,1,3]);
     coll = sum(coll,3);
     csi_mat(:,i) = coll;
end
```
The *for* loop accounts for NLOS/multipath/multidimenstional coefficient matrices

channel_sim.m gets called by decentralized_MIMOsim.m in the following code
```Matlab
    if par.iid == 1
        H = sqrt(0.5/par.MR)*...
          (randn(par.MR,par.MT)+1i*randn(par.MR,par.MT));
    else  
      H = channel_sim(par);
        norm_coef = zeros(1,par.MT);                    
        for i = 1:par.MT
            for j = 1:par.MR
                norm_coef(i)=norm_coef(i)+norm(H(j,i)); %sum the 2-norms of each column
            end
            norm_coef(i) = norm_coef(i)/par.MT;         %average the 2-norm sum
            H(:,i) = H(:,i)/norm_coef(i);               %divide each entry of QuaDRiGa channel by avg 2-norm
%             H(:,i) = H(:,i)/var(H(:,i));                %divide by variance of each column...?
        end
    end
    % transmit over noiseless channel (will be used later)
    x_send = H*s;
```
When initially generated, the coefficients look like below (x-axis being real, y-axis being imaginary):

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/channel_coef_before_norm.png)

What this means, and was confirmed by taking the 2-norm of the entries of each column, is that each receiver receives a same 2-normed coefficient. There are equal number of rings as receivers (8), and the column entries have equal 2-norms, although, they may differ across columns. I believe this is reasonable since the different elements of the BS would want to have the same power being transmitted, but just at different phases to do the beam-forming. 

However, these coefficients are still very small and would kill the **x_send** message, so the idea of normalizing the columns was introduced. Before realizing that the 2-norm along each column was the same, I used the method seen above to sum the 2-norms of all the entries of a column then divide by the number of entries in a column -> average 2-norm, then divide each entry by that average. The initial Gaussian approximation also multiplies by sqrt(1/MR) which was not the case in the simpleMIMOsim, but I did not include that in the code since it seemed to make the Quadriga results even worse (to be shown later).
After normalizing, the coefficients look like this:

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/channel_coef_after_norm.png)

### I believe this was the type of normalization discussed, but if that is wrong, I will fix it.

The rest of the code was mostly left alone, allocating just for parameterization/graphing purposes. The results do not appear to be in favor of the decentralization algorithms...? Also, there seems to be significant losses the greater the par.C parameter gets (number of decentralization divisions)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/parC_2comp.png)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/parC_4comp.png)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/parC_8comp.png)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/cg_dcg_mf_comp_parC2.png)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/cg_dcg_mf_comp_parC4.png)

![alt_text](https://github.com/JamesMcNaney/Summer19_MIMO/blob/master/Quadriga/tutorials/figures_images/cg_dcg_mf_comp_parC8.png)
